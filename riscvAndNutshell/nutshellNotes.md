> 学习果壳项目时的相关笔记



![图1：果壳整体的微结构设计](https://s2.loli.net/2022/11/07/HRToyx8v9XMhSi5.png)

<!--more-->

[TOC]

# 前端(Front End)设计

前端主要完成以下的功能：

1. 在“**分支预测**”中计算下一条PC的值，如果分支预测判断不跳转，则PC+8
2. 根据PC从**指令缓存(I-Cache)**中读取一个Cache Line(64 bits)的数据，可以转化成两条普通的32 bits指令或者4条压缩的16 bits指令
3. 得到的指令会被压入到**指令对齐缓冲(IBF)**，为了处理引入 RISC-V 压缩指令 RVC 后的指令对齐问题，前端设置了单独的指令对齐缓冲。它执行以下的功能：
   1. 判断指令的长度并将不同的指令分离
   2. 如果有指令横跨两次 ICache 结果, 指令对齐缓冲会负责将其拼接成一条指令
   
   指令对齐缓冲得到的指令会交给指令译码单元(IDU)进行译码

## 分支预测(Branch Prediction)

### 概述

1. 使用 **Next-Line** 分支预测器 (NLP)
2. 预测不跳转的时候，PC+8，因为一次读取一个Cache Line的数据是64 bits，按照字节寻址
3. 默认使用**两位饱和计数**进行预测
4. ~~分支预测器在后端跳转指令写回时更新~~
5. ~~提供 512 项的跳转目标缓存 (BTB) 和 16 项的返回地址栈 (RAS)~~
6. 针对 64 bits 的取指宽度, NLP 会*返回 4 bits 的跳转预测向量*，跳转预测向量标识在哪条指令处可能发生跳转。指令对齐缓冲将使用跳转预测向量来选择有效的指令

### NLP(Next Line Predictor)

> 在转移指令的<u>取指阶段预测出指令跳转的方向和目标地址</u>, 并从预测的目标地址处继续取指令执行, 在一定程度上减轻指令流水线中转移指令引起的阻塞

![图2：NLP的原理图](https://s2.loli.net/2022/11/07/HSBR3mr61fo27td.png)

1. NLP的结构如上图所示，其中各部分的作用如下：

   - BTB(branch target buffer)：用来记录指令跳转的历史。如果某条PC对应的指令是跳转指令，在该PC会被记录到BTB中，对应的指令的跳转信息也会被记录到BTB中。当下一次该PC出现的时候，则该PC可以在BTB中找到对应的跳转信息。
   - RAS(return address stack)：当BTB中分支跳转指令的类型是**ret**指令时，则选择RAS栈顶的地址作为跳转目的PC
   - PHT(pattern history table)：当BTB中分支跳转指令的类型是**条件跳转指令**时，需要访问模式历史表 (PHT) 来判断是否跳转。PHT中存放条件跳转指令是否跳转的记录。

2. BTB的结构

   ![image-20221107104800385](https://s2.loli.net/2022/11/07/LWypxSu26etGsT9.png)

   - PC跟tag进行匹配，如果匹配成功了，则可以根据BTB对应的表项来执行相应的跳转操作
   - 如果匹配的类型type是*直接跳转指令*或者*间接跳转指令*，则跳转的目标是target字段的值；如果匹配的类型是*ret指令*，则跳转的目标是RAS的栈顶的值
   - 更新操作：

3. RAS的结构

4. PHT的结构